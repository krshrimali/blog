[{"categories":null,"contents":"Prefer deleted functions to private undefined ones This item (11) in the chapter 3 focuses on:\n Why and How to prevent users calling particular functions? C++-98 and C++-11 approach What\u0026rsquo;s the difference between deleting a function vs declaring a member function private (and not defining them)?   NOTE\nThese are my notes on Chapter 3, Item 11 of Effective Modern C++ written by Scott Meyers.\nSome (or even all) of the text can be similar to what you see in the book, as these are notes: I\u0026rsquo;ve tried not to be unnecessarily creative with my words. :)\n  When is it required to delete a function/not define a private member function?  Problem:\n Cases when you don\u0026rsquo;t want the client to call a particular function.  Solution:\n Just don\u0026rsquo;t declare the function  But\u0026hellip;doesn\u0026rsquo;t work always:\nCase: Special member functions generated by C++ automatically, discussed later). Examples considered in this blog:\n Copy Constructor Copy Assignment Operator  C++-98 Approach:\n  Declare these functions private and don\u0026rsquo;t define them.\n  Example:\n All istream and ostream objects inherit (possibly) from basic_ios class in the C++ Standard Library. Copying these objects is undersirable.    Why is copying objects of istream and ostream undesirable? [Also see this question on stackoverflow]\n istream object: represents stream of input values.  some might have been read before. and some may be read later.   If you copy istream object:  Will that copy those values which have been read before? Or will also copy values which are to be read later?      Hence, it\u0026rsquo;s just better to not allow copying istream or ostream objects.\nIn C++-98: Reminder (from above): All istream and ostream objects inherit from basic_ios class (possibly) in the C++ standard, and the basic_ios class in C++-98 looks something like this:\ntemplate \u0026lt;class charT, class traits = char_traits\u0026lt;T\u0026gt; \u0026gt; class basic_ios : public ios_base { public: // ...  // Declaring the copy constructor and copy assignment operator private prohibits clients from calling them private: basic_ios(const basic_ios\u0026amp;); // not defined  basic_ios\u0026amp; operator=(const basic_ios\u0026amp;); // not defined }; Note that:\n basic_ios(const basic_ios\u0026amp;) is the copy constructor basic_ios\u0026amp; operator=(const basic_ios\u0026amp;) is the copy assignment operator  (and both are private).\nHow does not defining these functions help?\n Consider a case where a friend class or member functions try accessing these functions, then linking will fail because of missing function definitions.  In C++-11 In C++-11, the above can be done using = delete to mark the copy constructor and the copy assignment operator as deleted functions.\ntemplate \u0026lt;class charT, class traits = char_traits\u0026lt;charT\u0026gt; \u0026gt; class basic_ios : public ios_base { public: // ...  basic_ios(const basic_ios\u0026amp; ) = delete; // deleted function  basic_ios\u0026amp; operator=(const basic_ios\u0026amp;) = delete; // deleted function  // ... }; It\u0026rsquo;s a convention to declare deleted functions public, but why? Better error messages.\nIn case you declare your deleted functions private, some compilers will probably complain about the function being private and can hide the error message of it not being usable (because it being deleted). Hence, it\u0026rsquo;s a good practice to make them public:\nFrom my experience though, Apple\u0026rsquo;s clang compiler (v 12.0.5) doesn\u0026rsquo;t complain about it being private, but then - it can vary from compiler to compiler, so better to play safe. Here is an example of how the error message looks like:\n#include \u0026lt;iostream\u0026gt; class Sample { public: Sample(int x) : x(x) { }; // Copy constructor has been deleted, so should not be callable  Sample(const Sample\u0026amp;) = delete; void trying_copy_construct(Sample s) { // This function tries to use a copy constructor  // This should fail  Sample new_object(s); } private: int x; }; Compiling the above code fails with the following error:\nmain.cpp:10:16: error: call to deleted constructor of \u0026#39;Sample\u0026#39; Sample new_object(s); ^ ~ main.cpp:6:5: note: \u0026#39;Sample\u0026#39; has been explicitly marked deleted here Sample(const Sample\u0026amp;) = delete; Difference b/w using delete vs declaring private Note: There is more to it except the good practice reasoning.\n Using a deleted function in a member function or by a friend class won\u0026rsquo;t even compile the code if it tries to copy basic_ios objects while declaring private will compile successfully but fail during link-time. Conventionally deleted functions are declared public, not private while the C++-98 way requires the functions to be declared private (see the section above for reasoning). Only member functions can be private, while any function can be deleted (so you can delete some overloads for your function, in case you don\u0026rsquo;t want it to accept certain type inputs).  Let\u0026rsquo;s discuss the last point in detail:\nConsider the case where you have:\ntemplate\u0026lt;typename T\u0026gt; void processPointer(T* ptr); And:\n You need a template that works with built-in pointers. You want to reject calls with void* and char* pointers (more on this later, these deserve special handling at times). Ideal way? Delete these instantiations (with void* or char* input pointers).  template\u0026lt;\u0026gt; void processPointer\u0026lt;void\u0026gt;(void*) = delete; template\u0026lt;\u0026gt; void processPointer\u0026lt;char\u0026gt;(char*) = delete; But, with C++-98 way, it\u0026rsquo;s not possible within the class scope. That is, you can not give template specialization to your member function within the class scope (it should be done in the namespace scope):\nclass Sample { public: // ...  template \u0026lt;typename T\u0026gt; void processPointer(T* ptr) { ... } private: // ...  // This is template specialization inside the scope of the class - not allowed  template \u0026lt;\u0026gt; void processPointer\u0026lt;void\u0026gt;(void*); // error }; While with the C++-11 way, you can delete function outside the class scope:\nclass Sample { public: // ...  template \u0026lt;typename T\u0026gt; void processPointer(T* ptr) { ... } // ... }; template \u0026lt;\u0026gt; void Sample::processPointer\u0026lt;void\u0026gt;(void*) = delete; // in public scope, and deleted! I hope you liked this blog, thank you for reading! :)\n","permalink":"https://krshrimali.github.io/posts/2021/08/prefer-deleted-functions-to-private-undefined-ones-notes/","tags":null,"title":"Prefer Deleted Functions to Private Undefined Ones (Notes)"},{"categories":null,"contents":"Scoped vs Unscoped Enums  General rule: declaring a name inside curly braces is limited to that scope. Exception: C++-98 style Enums   NOTE\nMy notes on Chapter 3, Item 10 of Effective Modern C++ written by Scott Meyers.\nSome (or even all) of the text can be similar to what you see in the book, as these are notes: I\u0026rsquo;ve tried not to be unnecessarily creative with my words. :)\n // You can\u0026#39;t declare black, white, red in the scope containing the enum Color enum Color { black, white, red; }; auto white = false; // error: white already declared in this scope  Unscoped Enums have implicit type conversions for their enumerators. Enumerators can implicitly convert to integral types, and then to floating-point types.  // Assume Color is declared like above Color c = red; // valid since Enumerator white is leaked to the scope Color is in if (c \u0026lt; 10) { // valid, implicit conversion  // ... do something } else if (c \u0026lt; 10.5) { // also valid, implicit conversion  // ... do something } The C++-98 Style Enums are termed as Unscoped Enums (because of leaking names).\nC++-11 Scoped Enums:\n// black, white, red are now scoped to Color Enum enum class Color { black, white, red; }; // This is now valid auto white = false; Separately, if you do: (consider Color Enum has already been declared)\nColor c = white; // error: no enumerator named \u0026#34;white\u0026#34; is in this scope Color c = Color::white; // valid auto c = Color::white; // valid  Also referred as enum classes (because declared using enum class). Enumerators in scoped Enums are strongly typed (no implicit type conversion)  // Assume Color is declared as above using enum class Color c = Color::red; if (c \u0026lt; 10.5) { // Error! can\u0026#39;t compare Color and double  // do something... } Note: you can do explicit casting using cast. Note about enums in C++: * Every enum in C++ has an integral underlying type that is determined by compilers. * Compilers need to know the size of enum before using it.\nC++98 vs C++11 on Enums C++98:\n Unscoped enums can not be forward-declared.  Hence only enums with definitions are supported. Allows compilers to choose underlying type for each enum prior to the enum being used.   Drawbacks?  Increase in compilation dependencies: wherever the enum is used, even if not affected by any addition in the enum, it will be recompiled (generally speaking, that is without any tweaks/optimizations).    C++11:\n Both unscoped and scoped enums can be forward-declared. Unscoped enums will need a few efforts though:  /* For Scoped Enums */ // Default underlying type is int enum class Status; // Override it enum class Status: std::uint32_t; /* For Unscoped Enums */ // There is no underlying type for unscoped enum // You can manually specify though enum Status: sd::uint32_t; These specifications for underlying types can also go on enum\u0026rsquo;s definitions.\nUnscoped Enums over Scoped Enums? Imagine when you have a code like this:\n// Ordered as: name, email, reputation using UserInfo = std::tuple\u0026lt;std::string, std::string, std::size_t\u0026gt;; UserInfo uInfo; // This is not clear to the reader, you can\u0026#39;t always remember what 1st indexed field in UserInfo is auto val = std::get\u0026lt;1\u0026gt;(uInfo); Using the property of intrinsic conversion in unscoped enums, you can solve this:\nenum InfoFields { uName, uEmail, uReputation }; // UserInfo defined as above UserInfo uInfo; // Implicit conversion of int (default underlying type of enums) to std::size_t (that\u0026#39;s what std::get takes) auto val = std::get\u0026lt;uEmail\u0026gt;(uInfo); For scoped enums though, you\u0026rsquo;ll have to use static_cast\u0026lt;std::size_t\u0026gt;(InfoFields::uEmail) instead of just uEmail (for unscoped enums) passed to std::get, which is less readable. But\u0026hellip;\nThis can be redued by using a custom function which: * takes: enum * returns: corresponding std::size_t value\nstd::get is a template, and the value needs to be understood during compilation only, so the function should be a constexpr (more on this later in the series).\nTo generalize, let\u0026rsquo;s keep the enum\u0026rsquo;s underlying type (std::underlying_type type trait)\n// Using noexcept because we know there\u0026#39;ll be no exceptions raised template \u0026lt;typename E\u0026gt; constexpr typename std::underlying_type\u0026lt;E\u0026gt;::type toUType(E enumerator) noexcept { return static_cast\u0026lt;typename std::underlying_type\u0026lt;E\u0026gt;::type\u0026gt;(enumerator); } From the previous blog, we know that in C++14, we could have simplified by writing:\n// Using noexcept because we know there\u0026#39;ll be no exceptions raised template \u0026lt;typename E\u0026gt; constexpr std::underlying_type_t\u0026lt;E\u0026gt; toUType(E enumerator) noexcept { return static_cast\u0026lt;std::underlying_type_t\u0026lt;E\u0026gt;\u0026gt;(enumerator); } Could have used auto for return type in C++14:\n// Using noexcept because we know there\u0026#39;ll be no exceptions raised template \u0026lt;typename E\u0026gt; constexpr auto toUType(E enumerator) noexcept { return static_cast\u0026lt;std::underlying_type_t\u0026lt;E\u0026gt;\u0026gt;(enumerator); } Now this can be used as:\n// Reminder, InfoFields was defined as: enum InfoFields { uName, uEmail, uReputation }; // toUType is defined above auto val = std::get\u0026lt;toUType(InfoFields::uEmail)\u0026gt;(uInfo); Good Reads  Forward Declaration:  Stackoverflow: https://stackoverflow.com/questions/4757565/what-are-forward-declarations-in-c   Are Unscoped Enums still helpful?  Stackoverflow: https://stackoverflow.com/questions/27320603/are-unscoped-enumerations-still-useful   Proposal for forward declaration to enums (accepted), dated 2008: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf Forward Declaring an Enum in C++?  Stackoverflow: https://stackoverflow.com/questions/71416/forward-declaring-an-enum-in-c    Acknowledgement (Reviews) Thanks to Kshitij Kalambarkar for helping in reviewing the blog. It\u0026rsquo;s always helpful to get another set of eyes to what you write. :)\nThat\u0026rsquo;s it for this blog, thank you for reading everyone!\n","permalink":"https://krshrimali.github.io/posts/2021/08/prefer-scoped-enums-over-unscoped-enums-notes/","tags":null,"title":"Prefer Scoped Enums over Unscoped Enums (Notes)"},{"categories":null,"contents":"Hi Everyone, today I want to talk about Union Find Problem. This is going to be a series covering:\n Union Find Problem (this blog) Solutions to Union Find (1): Quick Find Solutions to Union Find (2): Quick Union Solutions to Union Find (3): Weighted Quick Union Applications of Union Find (perculation and more) Cool project using Union Find Solving some competitive programming questions using Union Find  Each blog will try to cover very basic concepts behind the topic, and also what it\u0026rsquo;s all about.\nUnion Find Problem: Definition Let\u0026rsquo;s define the problem first. It\u0026rsquo;s a problem where you need to find whether two points/objects are in a connected relationship (defined below) or not in a defined environment (where you know the relationships).\nConnection Relationship is an equivalence relation, which means:\n It\u0026rsquo;s reflexive: a ~ a (a is connected to itself) It\u0026rsquo;s symmetric: a ~ b iff b ~ a (a is connected to b iff b is connected to a OR if a is connected to b, b is also connected to a) It\u0026rsquo;s transitive: if a ~ b and b ~c then a ~ c (if a is connected to b, and b is connected to c, then a is connected to c)  And by connected, we just mean that there is a path between the two objects. My thinking around this problem is mostly surrounded by the plot of dynamic connectivity, where you want to find if there is a connection between 2 objects in a graph. These objects can be friends (whether A and B are friends or not in a circle - here circle is the environment).\nUnion Find: Problem, why study it? It\u0026rsquo;s a name to a problem, but you must have encountered this in real life. Whether you are a friend to your ex, oh definitely not ;) (even if Union Find solution finds a connection, trust me - move on :P). Okay, on a serious note now:\nUnion Find Problem is seen in lots of applications:\n Perculation (example: if you pour water on the top of a tank having lots of cells/blocks - some are open, some are closed - will it reach the bottom?).  I also see this as an application where you want to find if the leakage in a whole network of oil pipes will exit or if it will be blocked.   Dynamic Connectivity: A very simple definition would be, whether there is a connection between two objects?  You can see it\u0026rsquo;s application in social media, whether two objects (I know I should use humans but the whole internet objectifies you ;), hence objects ;)). Whether there is a connection between two places in a nation or not?   Games (will be discussed later) and more\u0026hellip;  Now it\u0026rsquo;s indeed a very interesting problem, and in this blog, I\u0026rsquo;ll show you a very basic implementation which I wrote before studying the algorithms which attempt to solve this problem.\nUnion Find breakdown: Union and Find  NOTE\nAll codes are written here in C++ and code is available here: https://github.com/krshrimali/Algorithms-All-In-One/.\n Breaking it down to two functions, is really helpful:\n// Object is an arbitrary type for now, can be an int, can be a user defined type as well void union(Object a, Object b) { // This function will connect two objects, if:  // * they exist  // * there isn\u0026#39;t a connection already  // ... } Similarly, the find function will try to find whether there is a connection between two objects:\n// Object is an arbitrary type for now, can be an int, can be a user defined type as well bool find(Object a, Object b) { // returns true if:  // * both objects exist  // * and they are connected  // else returns false  // ... } Let\u0026rsquo;s try to setup the environment first, and we need to answer these two questions first:\n What should be the objects? Where are these objects stored?  I like thinking of this as a graph (environment) and points as objects. So let\u0026rsquo;s start implementing.\nImplementation: Modelling  NOTE\nThis is a very basic implementation and first try presenting a naive solution to the problem, we\u0026rsquo;ll discuss better algorithms in next blogs.\n The very first question you should ask yourself is, what data structures should be used for Graph and Point(s)? The way I\u0026rsquo;m thinking of solving this is:\n Each Point will have (x, y) coordinates. (so coordinates will be it\u0026rsquo;s property) Whenever two points are merged (union is called), the first point will append the second point in it\u0026rsquo;s list of connections.  So each Point object will have a connection list. (std::vector?)   Whenever find is called, that is - there is an attempt to find if there is a connection between two points?  We just need to search if second point is there in the first point\u0026rsquo;s connection list. If it is, then there is a connection. And if not, then no connection. In python, I would have used a dict, so I went ahead with std::map in C++, will help me not duplicating points.    So the Graph will be a std::map of Point, std::vector\u0026lt;Point\u0026gt;, which will look something like this:\n// This is how graph will look like, in imagination // Example: // a is connected to b, c, d // b is connected to a (Point a, {Point b, Point c, Point d}), (Point b, {Point a}), ...so on As you can see, there will be a list mapped to each Point, we call that list: connection list.\nNow, the Point can simply be a struct having int x, y as coordinates.\nImplementation: Skeleton Let\u0026rsquo;s create the skeleton now:\nstruct Point { // x and y are the coordinates for each point  int x, y; }; // Graph will contain Points, helper functions: union and merge class Graph { private: std::map\u0026lt;Point, std::vector\u0026lt;Point\u0026gt;\u0026gt; graph; public: // We take references to avoid internal copies, const is used since we don\u0026#39;t want these functions  // to modify these points in any way  void union_(const Point\u0026amp; a, const Point\u0026amp; b) { // Use find utility function of std::map  if (this-\u0026gt;graph.find(a) == this-\u0026gt;graph.end()) { // Not found  // Means create an entry in the graph, and add b to the connection list of a  this-\u0026gt;graph[a] = {b}; } else { // Found  // Append b to the connection list of a  this-\u0026gt;graph.at(a).push_back(b); } } // Are a and b connected? OR Is there a path b/w a and b?  bool find_(const Point\u0026amp; a, const Point\u0026amp; b) { // First check if there is an Point a in the graph  if (this-\u0026gt;graph.find(a) == this-\u0026gt;graph.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; return false; } else { // Object found  std::vector\u0026lt;Point\u0026gt; connection_list = this-\u0026gt;graph.at(a); // Now find if b exists in the connection list, if yes then there is a connection  if (std::find(connection_list.begin(), connection_list.end(), b) != connection_list.end()) { // b found  return true; } return false; } } }; // Usage int main() { Graph g_sample; struct Point p(2, 3); struct Point q(3, 3); struct Point r(4, 4); // Add a connection for (p, q) and (p, r), for testing  g_sample.union_(p, q); g_sample.union_(p, r); std::cout \u0026lt;\u0026lt; \u0026#34;Are p and q connected? Answer: \u0026#34; \u0026lt;\u0026lt; sampleGraph.find_(p, q) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // Expected: true  std::cout \u0026lt;\u0026lt; \u0026#34;Are p and r connected? Answer: \u0026#34; \u0026lt;\u0026lt; sampleGraph.find_(p, r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // Expected; true  std::cout \u0026lt;\u0026lt; \u0026#34;Are q and r connected? Answer: \u0026#34; \u0026lt;\u0026lt; sampleGraph.find_(q, r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // Expected: false } Now this is a great start, I won\u0026rsquo;t spend time explaining the code as the comments should help. In case you have queries, please feel free to open an issue here.\nBut this won\u0026rsquo;t compile. And the reason is, that when you are using std::find with user-defined types like Point, you need to define \u0026lt; operator or give it a comparator because it does some comparisons. Think of this like:\nThe compiler isn\u0026rsquo;t aware of how to do: Point(2, 3) \u0026lt; Point(3, 3)\nBecause for the compiler, both of these are an object. So we need to tell it explicitly, that hey! when you do \u0026lt; operation on Point objects, check their coordinates.\nFinal Implementation The final code can be found here. There are a few TODOs in the code mentioned, and in case you want to pick them up, please create a PR for the same. :)\nThe code will change with time, so I\u0026rsquo;ll refrain copy-pasting it here.\nHomework? Let\u0026rsquo;s do this before I release the next blog:\n Analyze the algorithm used here, it\u0026rsquo;s time and space complexity. Address the TODOs in the code.  In case you are able to do this before my next blog, kudos to you! You might as well help creating a PR, that will be great.\nThank you for reading this blog. I hope you liked it! :)\n","permalink":"https://krshrimali.github.io/posts/2021/08/union-find-problem-and-a-naive-implementation-c-/","tags":null,"title":"Union Find Problem, and a naive implementation (C++)"},{"categories":null,"contents":"One solution to avoiding using long type names:\n// So C++98 like typedef std::unique_ptr\u0026lt;std::unordered_map\u0026lt;std::string, std::string\u0026gt;\u0026gt; UPtrMapSS;  NOTE\nMy notes on Chapter 3, Item 9 of Effective Modern C++ written by Scott Meyers.\nSome (or even all) of the text can be similar to what you see in the book, as these are notes: I\u0026rsquo;ve tried not to be unnecessarily creative with my words. :)\n C++11 also offers alias declarations:\nusing UPtrMapSS = typedef std::unique_ptr\u0026lt;std::unordered_map\u0026lt;std::string, std::string\u0026gt;\u0026gt;; Advantages of alias declarations over typedefs:\n  For types involving function pointers, aliases are easier to read (for some people):\n// typedef typedef void (*FP)(int, const std::string\u0026amp;); // alias declaration using FP = void (*)(int, const std::string\u0026amp;);   Alias declarations can be templatized, but typedefs can not.\n// MyAlloc is a custom allocator template \u0026lt;typename T\u0026gt; using MyAllocList = std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;; MyAllocList\u0026lt;Widget\u0026gt; lw; // will create std::list\u0026lt;Widget, MyAlloc\u0026lt;Widget\u0026gt;\u0026gt; vs: typedef, a hack way:\n// templatized struct here template \u0026lt;typename T\u0026gt; struct MyAllocList { typedef std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; type; }; MyAllocList\u0026lt;Widget\u0026gt;::type lw;   In case you want to use a type specified by template parameter, with typedefs it gets complex:\n// MyAllocList is defined as mentioned in 2nd point template \u0026lt;typename T\u0026gt; class Widget { private: typename MyAllocList\u0026lt;T\u0026gt;::type list; // ... };  Here MyAllocList\u0026lt;T\u0026gt;::type is now a dependent type (dependent on type T from template paramater). C++ Rule: need to use typename before name of a dependent type.  With alias declaration of MyAllocList, no need to use typename and ::type:\ntemplate \u0026lt;typename T\u0026gt; class Widget { private: // no typename and ::type  MyAllocList\u0026lt;T\u0026gt; list; // ... }   Explanation on the 3rd point:\n Compiler understands the alias declared MyAllocList when used inside a template class Widget as MyAllocList\u0026lt;T\u0026gt; is not a dependent type. A user can have type as a data member, and thus it\u0026rsquo;s important to mention typename when using MyAllocList\u0026lt;T\u0026gt;::type (as a type), so that compiler knows it\u0026rsquo;s a type.  Creating revised types from template type paramaeters is a common practice in Template Meta Programming (TMP). A few important points to note:\nIn C++11 (in header: \u0026lt;type_traits\u0026gt;):\nstd::remove_const\u0026lt;T\u0026gt;::type // yields T from const T std::remove_reference\u0026lt;T\u0026gt;::type // yields T from T\u0026amp; and T\u0026amp;\u0026amp; std::add_lvalue_reference\u0026lt;T\u0026gt;::type // yields T\u0026amp; from T In case you are applying the above transformations inside a template to a type parameter, you\u0026rsquo;ll have to use typename. This is because they have been implemented as typedefs inside templatized structs.\nIn C++14, their alias equivalent were added which do not require you to prefix typename:\n// equivalents to the above 3 transformations std::remove_const_t\u0026lt;T\u0026gt; std::remove_reference_t\u0026lt;T\u0026gt; std::add_lvalue_reference\u0026lt;T\u0026gt; Acknowledgement\n Thanks to Kshitij Kalambarkar for reviewing this blog.  Thanks for reading!\n","permalink":"https://krshrimali.github.io/posts/2021/08/prefer-alias-declarations-to-typedefs-notes/","tags":null,"title":"Prefer Alias Declarations to Typedefs (Notes)"},{"categories":null,"contents":"In today\u0026rsquo;s blog, we\u0026rsquo;ll talk about two important concepts in C++: Function Pointers and Function Objects.\nPlease note that, function objects are commonly referred as functors but we have failed to notice any official alias to the name. Hence, we\u0026rsquo;ll restrict ourselves to using Function Objects in this blog.\nFunction Pointers As the name sounds, a function pointer is simply a pointer to the memory address of a function. Consider a following function:\n// A function which returns true if a \u0026gt; b else false bool isGreater(int a, int b) { return a \u0026gt; b; } As we would expect, the function is stored in the memory starting with an address. You can print the memory address of a function by doing (we do this using printf, see: https://stackoverflow.com/a/2064722)\nauto fn_addresss = isGreater; // get the address of the function printf(\u0026#34;Function address: %p\\n\u0026#34;, fn_address); And you\u0026rsquo;ll notice a hex value as the output: 0x5649d675c139 (in my case). The syntax for creating a function pointer looks like this:\nreturn_type (*ptr_name)(arg1_type, arg2_type, ...); So in our case for isGreater, it will be:\nbool (*justApointer)(int, int); What this means is, the pointer justApointer will point to a function taking 2 integer arguments and returning a boolean value. But note that this doesn\u0026rsquo;t point to any function yet. If you will do:\nbool (*justApointer)(int, int); // De-reference the pointer and call (*justApointer)(3, 4); This will cause a segmentation fault (core dumped) error because it points to no valid address of an executable code. So let\u0026rsquo;s go ahead and point our pointer to the memory address of isGreater:\njustApointer = \u0026amp;isGreater; Here we have given the address of the function to the pointer, you can also do:\n// Note: It\u0026#39;s a good practice to avoid writing the type of function pointers again if it\u0026#39;s too verbose using FnType = bool (*)(int, int); FnType justApointer{ \u0026amp;isGreater }; // OK FnType yetAnotherPointer = \u0026amp;isGreater; // OK FnType yetAnotherFnPointer = isGreater; // OK, implicit conversion happens in C++ from function to function pointer, so you don\u0026#39;t need to use \u0026amp; operator You could also have declared the pointer first, and then initialized:\n// Declararation bool (*justApointer)(int, int); // Initialization justApointer { \u0026amp;isGreater }; justApointer { isGreater }; justApointer = \u0026amp;isGreater; justApointer = isGreater; All of this is valid and works in C++. If you\u0026rsquo;re coming from Modern C++, you might have realized that it\u0026rsquo;s OK to skip the syntax of a function pointer and use:\nauto justApointer = isGreater; Calling a function pointer is fairly straight forward, you can just do:\n// Will return 0 since 3 is not greater than 4 std::cout \u0026lt;\u0026lt; (*justApointer)(3, 4); Since it\u0026rsquo;s a pointer, so you have to de-reference it to get to the function address (executable code in the memory) and then call it using the () call operator. C++ does the implicit conversion, and you can skip de-referencing:\n// Will also return 0 since 3 is not greater than 4 std::cout \u0026lt;\u0026lt; justApointer(3, 4); If you are familiar with concepts of const pointers, you can also create a const function pointer, so that once initialized - it can not be pointed to a different function.\nbool (*const justApointer)(int, int) = \u0026amp;isGreater; // You can not re-initialize (aka assign) it to point to any other address justApointer = \u0026amp;isGreater; // NOT OK, ERROR: assignment of read-only variable \u0026#39;justApointer\u0026#39; If you have noticed, we used *const justApointer - since we wanted to indicate to the compiler - that the pointer is supposed to be const, not the output (const bool (*justApointer)(int, int)). You can play around with different specifiers and see how they work though.\nOne of the use-cases of function pointers is to be able to pass a function as an argument (often referred as Callback Functions). But well, you might have a question - you can use a global function in another function, right? Yes, that\u0026rsquo;s possible, but consider a case where you want to pass different callback functions depending on your requirement to a more generic function (like sorting).\nbool isGreater(int a, int b) { return a \u0026gt; b; } bool isLesser(int a, int b) { return a \u0026lt; b; } bool isEqual(int a, int b) { return a == b; } We have these 3 functions but we don\u0026rsquo;t know yet which one we want to use to sort an array, let\u0026rsquo;s say you want to sort an array in descending order, another array in ascending order.\nstd::vector\u0026lt;int\u0026gt; sample_vec = {0, 5, -3, 4, 9, 2}; void a_generic_sorting_function(std::vector\u0026lt;int\u0026gt; input_vec, bool (*comparisonFunction)(int, int)) { // ... sorting algorithm \t// use comparisonFunction for comparisons } a_generic_sorting_function(sample_vec, isGreater); // sorts in descending order a_generic_sorting_function(sample_vec, isLesser); // sorts in ascending order Observe that even though we passed a function as an argument, but eventually - that\u0026rsquo;s interpreted as a pointer (since that\u0026rsquo;s what the 3rd argument type is, in a_generic_sorting_function).\nFunction Objects  Function Objects are types that implement call operator ().\n Function Objects provide us 2 advantages over function pointers, which are mainly:\n Can be optimized by the compiler, if possible. Allows to store a state.  How can compiler optimize function objects? You\u0026rsquo;ll see this definition almost everywhere, and hence the quote. There is no better and simpler way to define a function object. But we\u0026rsquo;ll also focus on how can they make things easier + faster. A struct or a class in C++ which defines/implements call operator () can be referred as function object. Interestingly, in C++:\n std::plus is a function object implementing x + y. std::minus is a function object implementing x - y.  and many more arithmetic operators like /, *, % and negation (-x). See Operator Function Objects section in https://en.cppreference.com/w/cpp/utility/functional.\nThere are other comparison, logical and bitwise operations as well which are provided as function objects in C++. Let\u0026rsquo;s take a look at std::greater and std::lesser function objects to maintain the consistency b/w function pointers and objects sections. Going by the documentation (https://en.cppreference.com/w/cpp/utility/functional/greater), the struct std::greater implements the call operator ():\nbool operator() (const T\u0026amp; lhs, const T\u0026amp; rhs) const; // (until C++14) (source: https://en.cppreference.com/w/cpp/utility/functional/greater)\nIf we had to define our own function object, something similar to std::greater but only for integer inputs. As mentioned earlier, it\u0026rsquo;s a type with the call operator defined, so let\u0026rsquo;s go ahead and define our own struct:\nstruct greater { bool operator()(int a, int b) { return a \u0026gt; b; } }; greater comparison; std::cout \u0026lt;\u0026lt; comparison(3, 4); // Returns 0 Now you can ask: this could have been accomplished with a function pointer as well, so why a function object? Well, so the answer boils down to optimization (in this case). A compiler can inline the function if it\u0026rsquo;s possible to optimize the execution - and that\u0026rsquo;s only possible with function objects, while for function pointers - you need to de-reference it to know the address which happens during the runtime (unless there is some real complex optimization - which I\u0026rsquo;m not aware of right now).\nA real example can be to see the compiled code on https://godbolt.org/ (an amazing compiler explorer). If I compile the following code (on x86-64, gcc 11.1 with no optimization flags):\n#include \u0026lt;iostream\u0026gt; struct greater { bool operator()(int a, int b) { return a \u0026gt; b; } }; int main() { struct greater obj; std::cout \u0026lt;\u0026lt; obj(3, 4); } The relevant assembly code of the main function looks like this:\nmain: push rbp mov rbp, rsp sub rsp, 16 lea rax, [rbp-1] mov edx, 4 mov esi, 3 mov rdi, rax call greater::operator()(int, int) movzx eax, al mov esi, eax mov edi, OFFSET FLAT:_ZSt4cout call std::basic_ostream\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt;(bool) mov eax, 0 leave ret The above assembly code may look overwhelming to some, but the most relevant instruction is: (link to the code: https://godbolt.org/z/WqYozn7qv)\ncall greater::operator(int, int) Now if I add the optimization flag, you\u0026rsquo;ll see the operator being inlined:\nmain: sub rsp, 8 xor esi, esi mov edi, OFFSET FLAT:_ZSt4cout call std::basic_ostream\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;\u0026amp; std::basic_ostream\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;::_M_insert\u0026lt;bool\u0026gt;(bool) xor eax, eax add rsp, 8 ret _GLOBAL__sub_I_main: sub rsp, 8 mov edi, OFFSET FLAT:_ZStL8__ioinit call std::ios_base::Init::Init() [complete object constructor] mov edx, OFFSET FLAT:__dso_handle mov esi, OFFSET FLAT:_ZStL8__ioinit mov edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev add rsp, 8 jmp __cxa_atexit Though, it may not be visible on the first look, but a closer look to the following instruction:\ncall std::basic_ostream\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;\u0026amp; std::basic_ostream\u0026lt;char, std::char_traits\u0026lt;char\u0026gt; \u0026gt;::_M_insert\u0026lt;bool\u0026gt;(bool) tells us that it doesn\u0026rsquo;t call the operator of the object of type greater anymore! Instead, the compiler knows that the value is false and hence it inlines the value to the std::cout call. While this is possible for function objects, it\u0026rsquo;s not possible for function pointers (with the -O3 flag at least).\nStoring a state It\u0026rsquo;s more like a property of a class/struct in C++ that you can take arguments in the constructor and have different objects with different values for a member variable. Take an example:\n// Usage: // GreaterThan obj(10); // obj(11); // is 11 \u0026gt; 10? // // GreaterThan obj_(-10); // obj_(-9); // is -9 \u0026gt; -10? class GreaterThan { int compare_with; public: void greaterThan(int inp) : compare_with(inp) { } bool operator()(int another_number) { return another_number \u0026gt; compare_with; } }; int main() { GreaterThan obj(10); std::cout \u0026lt;\u0026lt; obj(11) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; GreaterThan obj_(-10); std::cout \u0026lt;\u0026lt; obj_(-9) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } Here you have a member variable compare_with and you can have different values for each object instantiated. While it\u0026rsquo;s also possible for a function by using a static variable but you can\u0026rsquo;t have multiple values for it on a single run.\nFunction Objects and Function Pointers in the Standard Library Function Objects and Function Pointers, just like any other type/value can be passed as a type to a template:\ntemplate \u0026lt;typename T, typename ComparatorFunc\u0026gt; void sort(T vector_input, ComparatorFunc func) { // ... sorting logic using given comparator function: func } This allows you to use sort as a generic function with different types of comparators. Let\u0026rsquo;s take a look here, you have 2 function object types: isGreater and isLesser: (the same can be done for function pointers as well)\nstruct isGreater { bool operator()(int a, int b) { return a \u0026gt; b; } } struct isLesser { bool operator()(int a, int b) { return a \u0026lt; b; } } template \u0026lt;typename T, typename ComparatorFunc\u0026gt; T sort(T input, ComparatorFunc func) { // use func to decide sorting strategy (descending/ascending) } This is valid in C++, though I\u0026rsquo;ll like to add a disclaimer here, you could have just used std::sort instead of implementing your own sorting strategy (unless you know what you are doing ;)):\nstd::sort(input.begin(), input.end(), isGreater); std::sort(input.begin(), input.end(), isLesser); This is mostly it for this blog, there is a lot to discuss about function pointers and objects, but I guess this should be enough for you to get started and follow us along in future blogs.\nAcknowledgement Every blog is published after lots of reviews and corrections, and it\u0026rsquo;s not just me but the efforts of the whole team which should be acknowledged. Thanks to Kshitij Kalambarkarfor helping me with the reviews and corrections. Shoutout to the whole malloc(42) team for helping me with this.\nReferences and Good Reads  Learn CPP\u0026rsquo;s Blog on Function Pointer. Function Objects in the STL (Microsoft Docs) CppReference: Function Objects. ","permalink":"https://krshrimali.github.io/posts/2021/07/function-pointers-and-function-objects-in-c-/","tags":null,"title":"Function Pointers and Function Objects in C++"},{"categories":null,"contents":"In the last blog post, I realized there were a lot of methods inherited from the base struct _Vector_base_ and _Vector_impl_data. Instead of directly going to the source code of these structs, I\u0026rsquo;ll go through their methods and objects by explaining what happens when we initialize a vector.\nThat is, we will start from calling a vector constructor and then see how memory is allocated. If you haven\u0026rsquo;t looked at the previous blog post, please take a look here. I want to be thorough with the blog post, so I\u0026rsquo;ll divide this into multiple posts. By the end of this post, you\u0026rsquo;ll go through the following structs:\n _Vector_impl_data struct which contains pointers to memory locations (start, finish and end of storage). _Vector_impl struct (inherits _Vector_impl_data as well)).  I usually opt for the bottom-up approach. Vectors can be initialized in many ways, three of them will be discussed in today\u0026rsquo;s blog. We\u0026rsquo;ll start from the very basic constructor of a vector using an initializer list and slowly reach to memory allocation and how the above 2 structs are used. Let\u0026rsquo;s start!\nUsing Initializer Lists So what happens when we initialize a vector with an initializer list?\nstd::vector\u0026lt;int\u0026gt; vec {1, 2, 3}; The vector class has many constructors in GCC depending on the type of inputs you give. Let\u0026rsquo;s take a look at the constructor when the input is an initializer list:\nvector(initializer_list\u0026lt;value_type\u0026gt; __l, const allocator_type\u0026amp; __a = allocator_type()) : _Base(__a) { _M_range_initialize(__l.begin(), __l.end(), random_access_iterator_tag()); } If you are curious what _Base is, _Base is declared as: typedef _Vector_base\u0026lt;_Tp, _Alloc\u0026gt; _Base;. Just so you know, where and how is _Vector_base used. When the constructor is called, it calls the constructor of _Vector_base with __a (allocator type). As you might have noticed, we are calling _M_range_initialize and passing 2 iterators (__l.begin(), __l.end()) and 1 forward iterator tag.\nNote that the iterators are Forward Iterators, that is: we can use these iterators to access elements from begin (accessed using .begin()) till the end (accessed using .end()).\nWe are using random_access_iterator_tag as forward_iterator_tag. This tag helps us to categorize the iterator as random-access iterator. Random-access iterators allow accessing elements by passing arbitrary offset position (see: http://www.cplusplus.com/reference/iterator/RandomAccessIterator/for more details).\nLet\u0026rsquo;s go ahead and see what _M_range_initialize does.\ntemplate \u0026lt;typename _ForwardIterator\u0026gt; void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) { const size_type __n = std::distance(__first, __last); this-\u0026gt;_M_impl._M_start = this-\u0026gt;_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator())); this-\u0026gt;_M_impl._M_end_of_storage = this-\u0026gt;_M_impl._M_start + __n; this-\u0026gt;_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this-\u0026gt;_M_impl._M_start, _M_get_Tp_allocator()); } Let\u0026rsquo;s go line by line.\n First we find the distance using std::distance which takes first and last iterators, and returns size such as: __last = __first + size. Next, we allocate memory for __n objects. The function this-\u0026gt;_M_allocate returns pointer to the starting location of the memory allocated. static size_type _S_check_init_len(size_type __n, const allocator_type\u0026amp; __a) { if (__n \u0026gt; _S_max_size(_Tp_alloc_type(__a))) __throw_length_error( __N(\u0026#34;cannot create std::vector larger than max_size()\u0026#34;)); return __n; }  The function _S_check_init_len is called by constructors to check size. If the requested size is greater than the maximum size for the allocator type, it throws length error (\u0026quot;cannot create std::vector larger than max_size()\u0026quot;). Else, it returns __n. Once we have validated the size, this-\u0026gt;_M_allocate call allocates the memory. Note that, _M_allocate is a part of _Vector_base struct. _M_allocate allocates memory for __n number of objects. This returns a pointer to the memory location (starting), to _M_start. The end of storage pointer stores the end of memory location for the memory allocated for __n objects. The function std::__uninitialized_copy_a copies the range [__first, __last) into the this-\u0026gt;_M_impl._M_start. This returns a pointer to memory location starting at this-\u0026gt;_M_impl._M_start with length of __first - __last.    To summarize, when we initialized vector with initializer list:\n It first calculates the number of objects to allocate memory for. This is assigned to __n. Then, memory is allocated for __n objects (including a check if this much memory can be allocated based on the allocator type, if not then it returns a length error). The pointer _M_start points to the starting memory location. The end of storage is the end location of the storage. Since we have passed the initializer list, so it knows the end of storage is starting location + len(initializer_list). The elements are then copied the range [__first, __last) into the memory allocated.  Depending on how you initialize your vectors, the process may change but overall, the intention is the same: to allocate memory (if valid) and set pointers (start, end of storage and finish).\nUsing similar value and specified number of elements (fill) Let\u0026rsquo;s take a look at an example of using\nstd::vector\u0026lt;int\u0026gt; vec(10, 0); The above constructor call will give you a vector of 10 elements with all zeros. You can print the elements using:\n// Instead of using auto, we can use // for (std::vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++) { // std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // } for (auto it = vec.begin(); it != vec.end(); it++) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; Let\u0026rsquo;s see what changes when the vector is constructed in the above mentioned way. Let\u0026rsquo;s take a look at the constructor which is called:\nvector(size_type __n, const value_type\u0026amp; __value, const allocator_type\u0026amp; __a = allocator_type()) : _Base(_S_check_init_len(__n, __a), __a { _M_fill_initialize(__n, __value); } As the documentation of the above constructor explains, this constructor fills the vector with __n copies of __a value. Note the use of _S_check_init_len here (we discussed this before). Instead of calling _M_range_initialize, _M_fill_initialize is called here. For our example, this function is passed with values: 10 (__n) and 0 (__value). Let\u0026rsquo;s take a look at the definition of _M_fill_initialize:\nvoid _M_fill_initialize(size_type __n, const value_type\u0026amp; __value) { this-\u0026gt;_M_impl._M_finish = std::__uninitialized_fill_n_a(this-\u0026gt;_M_impl._M_start, __n, __value, _M_get_Tp_allocator()); } The call __uninitialized_fill_n copies the value (__value, here 0) into the range [this-\u0026gt;_M_impl._M_start, this-\u0026gt;_M_impl._M_start + __n) and returns the end of it\u0026rsquo;s range. As per the documentation, it is similar to fill_n() but does not require an initialized output range. Wait, you might be wondering, we didn\u0026rsquo;t initialize this-\u0026gt;_M_impl._M_start! We did! Note that we called _Base(_S_check_init_len(__n, __a) when the constructor is called. _Base is nothing but a typedef of _Vector_base. Let\u0026rsquo;s take a look at this call:\n_Vector_base(size_t __n) : _M_impl() { _M_create_storage(__n); }  _M_impl is an object of type _Vector_impl declared in _Vector_base struct. _M_create_storage(__n) is defined as: void _M_create_storage(size_t __n) { this-\u0026gt;_M_impl._M_start = this-\u0026gt;_M_allocate(__n); this-\u0026gt;_M_impl._M_finish = this-\u0026gt;_M_impl._M_start; this-\u0026gt;_M_impl._M_end_of_storage = this-\u0026gt;_M_impl._M_start + __n; } This will answer most of your queries. Let\u0026rsquo;s start line by line.\n this-\u0026gt;_M_allocate(__n) was discussed before, which allocates memory for __n objects. Please note that the constructor call _M_impl() had initialized these pointers for us. Here, the pointer is set to the starting memory location. Since the function _M_create_storage creates storage, and doesn\u0026rsquo;t copy elements to the memory location. So this-\u0026gt;_M_impl._M_finish is set to this-\u0026gt;_M_impl._M_start. The end of storage is, as before, set to this-\u0026gt;_M_impl._M_start + __n.    So, eventually, it\u0026rsquo;s quite similar to what we saw when we initialized our vector with initializer list.\nUsing another vector (copy) Let\u0026rsquo;s take a look at another way to another initalize a vector:\nstd::vector\u0026lt;int\u0026gt; vec_copy {1, 2, 3}; std::vector\u0026lt;int\u0026gt; vec(vec_copy); // Try printing the elements of vec for (auto it = vec.begin(); it != vec.end(); it++) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; } When you call vec(vec_copy), the copy constructor is called. Let\u0026rsquo;s take a look at it\u0026rsquo;s definition:\nvector(const vector\u0026amp; __x) : _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()) { this-\u0026gt;_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this-\u0026gt;_M_impl._M_start, _M_get_Tp_allocator()); } The function body is similar to what we saw in the constructor definition when we initialized vector using size_type __n, value_type value. Notice how we initialize the base struct here. Let\u0026rsquo;s take a look at _S_select_on_copy(__x._M_get_Tp_allocator()) first. _M_get_Tp_allocator() returns _M_impl object.\nconst _Tp_alloc_type\u0026amp; _M_get_Tp_allocator() { return this-\u0026gt;_M_impl; } Note that, here, this-\u0026gt;_M_impl will already have the pointers set to the memory locations for start, finish and end of storage (as we use the allocator of __x). The objective is to use the copy of allocator object used by __x. Let\u0026rsquo;s take a look at the constructor of Base struct:\n_Vector_base(size_t __n, const allocator_type\u0026amp; __a) : _M_impl(__a) { _M_create_storage(__n); } Overall, it\u0026rsquo;s the same to what we saw before except that we use the copy of the alloactor of vector __x. The call _M_create_storage(__n) does the same task of setting pointers _M_start, M_end_of_storage, _M_finish as we observed before.\nFor today\u0026rsquo;s blog, we discussed 3 popular ways to initialize a vector in C++ and went through how memory is allocated when the constructors are called. As we move forward, we will slowly get familiar with the design patterns and methods used in GCC.\nAs always, I would love to hear your feedback on my blogs. Correct me if I was wrong anywhere, no one is perfect afterall. If this helped you, please let me know - it keeps me going! See you all in the next blog!\n","permalink":"https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-2-what-happens-when-you-initialize-a-vector/","tags":null,"title":"Understanding how Vectors work in C++ (Part-2): What happens when you initialize a vector?"},{"categories":null,"contents":"In this blog, we\u0026rsquo;ll continue diving deep into the source code of Vector Containers in GCC compiler. Today, we will be discussing some of the most commonly used methods of vectors, and how they are implemented.\nBefore we start, if you haven\u0026rsquo;t looked at the previous blogs in the C++ series, please take a look here. If you are already familiar with memory allocation in vector containers and vector\u0026rsquo;s base structs, then you can skip reading the previous blogs and continue here. If not, I suggest you reading them.\nLet\u0026rsquo;s start off with pop_back member function, which essentially deletes the last element from the vector and reduces the size by one. Let\u0026rsquo;s take a look how it is used:\n# Initialize a vector using initializer list std::vector\u0026lt;int\u0026gt; X {1, 2, 3}; X.pop_back(); for (auto const\u0026amp; element: X) { std::cout \u0026lt;\u0026lt; element \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } You will see the output as: 1 2. If you are wondering how this works in the case of a 2D vector, let\u0026rsquo;s take a look:\n# Initialize a 2D vector using initializer list std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; X { {1, 2, 3}, {4, 5, 6} }; X.pop_back(); for (auto const\u0026amp; element: X) { for (auto const\u0026amp; _element: element) { std::cout \u0026lt;\u0026lt; _element \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } You will see the output as: 1 2 3. As you can notice, it popped back the last element which was indeed a vector. Let\u0026rsquo;s start diving deep in the source code now, starting with declaration:\nvoid pop_back() { __glibcxx_required_nonempty(); __this-\u0026gt;_M_impl._M_finish; _Alloc_traits::destroy(this-\u0026gt;_M_impl, this-\u0026gt;_M_impl._M_finish); _GLIBCXX_ASAN_ANNOTATE_SHRINK(1); } A short note on _GLIBCXX_NOEXCEPT operator (noexcept since C++11): It returns true if the expression or member function is required to not throw any exceptions. _GLIBCXX_NOEXCEPT is defined as noexcept for C++ versions \u0026gt;= 2011:\nif __cplusplus \u0026gt;= 201103L # define _GLIBCXX_NOEXCEPT noexcept You can use a condition by using _GLIBCXX_NOEXCEPT_IF(condition) which essentially calls noexcept(condition). One use of this is when you want to access a particular index in a vector, you can avoid check if the location exists or not by using noexcept.\nWhen you call pop_back the design rule first checks if the vector is empty or not. If it\u0026rsquo;s nonempty, only then it makes sense to pop the last element, right? This is done by using __glibcxx_required_nonempty() call. The definition of this macro is:\n# define __glibcxx_requires_nonempty() __glibcxx_check_nonempty() As you can see, it\u0026rsquo;s calling __glibcxx_check_nonempty() macro which checks using this-\u0026gt;empty() call:\n# define __glibcxx_check_nonempty() \\ _GLIBCXX_DEBUG_VERIFY(! this-\u0026gt;empty(), _M_message(::__gnu_debug::__msg_empty)._M_sequence(*this, \u0026#34;this)) These are typical GCC macros for assertions. If we the vector is nonempty, we now move forward in fetching the last location in the memory of our vector container (using _M_impl._M_finish pointer), please take a look at the previous blogs if you aren\u0026rsquo;t aware of _M_impl struct. As the term suggests, we attempt to destroy the memory location using _Alloc_traits::destroy(this-\u0026gt;_M_impl, this-\u0026gt;_M_impl._M_finish). _Alloc_traits allows us to access various properties of the allocator used.\n// This function destroys an object of type _Tp template \u0026lt;typename _Tp\u0026gt; static void destroy(_Alloc\u0026amp; __a, _Tp\u0026amp; __p) noexcept(noexcept(_S_destroy(__a, __p, 0)) { _S_destroy(__a, __p, 0); } According to the official documentation of destroy static function: It calls __a.destroy(__p) if that expression is well-formed, other wise calls __p-\u0026gt;~_Tp(). If we take a look at the existing overloads of _S_destroy:\ntemplate \u0026lt;typename _Alloc2, typename _Tp\u0026gt; static auto _S_destroy(_Alloc2\u0026amp; __a, _Tp* __p, int) noexcept(noexcept(__a.destroy(__p))) -\u0026gt; decltype(__a.destroy(__p)) { __a.destroy(__p); } template \u0026lt;typename _Alloc2, typename _Tp\u0026gt; static void _S-destroy(_Alloc2\u0026amp; __a, _Tp* __p, ...) noexcept(noexcept(__p-\u0026gt;~_Tp())) { __p-\u0026gt;~_Tp(); } So clearly, if the expression is well-formed, it will call our allocator\u0026rsquo;s destroy method and pass the pointer location in that call. Otherwise, it calls the destructor of the pointer itself (__p-\u0026gt;~_Tp()). Once successfully done, we reduce the size by 1 using:\n# define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \\ _Base::_Vector_impl::template _Asan\u0026lt;\u0026gt;::_S_shrink(this-\u0026gt;_M_impl, n) As you would see, the macro calls _S_shrink function to sanitize the vector container (i.e. reduce the size by n, here 1):\ntemplate \u0026lt;typename _Up\u0026gt; struct _Asan\u0026lt;allocator\u0026lt;_Up\u0026gt;\u0026gt; { static void _S_adjust(_Vector_impl\u0026amp; __impl, pointer __prev, pointer _curr) { __sanitizer_annotate_contiguous_container(__impl._M_start, __impl._M_end_of_storage, __prev, __curr); } static void _S_shrink(_Vector_impl\u0026amp; __impl, size_type __n) { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); } } We don\u0026rsquo;t need to go deeper into these calls, but (as per official documentation), the call _S_adjust adjusts ASan annotation for [_M_start, _M_end_of_storage) to mark end of valid region as __curr instead of __prev (note that we already had deleted the last element, so __impl.__M_finish + __n (here __n is 1) will be the old pointer).\nA good useful note here is, that pop_back function isn\u0026rsquo;t marked noexcept as we already have conditions to check the container being non-empty. In case there is any failure, the debug macros are called and throw necessary exceptions.\nLet\u0026rsquo;s go ahead and take a look at a few other member functions (there are many, take a look here: https://en.cppreference.com/w/cpp/container/vector, I only discuss those which are commonly used)\n  back(): Let\u0026rsquo;s take a look at back call. As the name suggests (and as we saw before), this returns the last element in the vector container. It can be used as X.back() where X is a valid vector container. Let\u0026rsquo;s take a look at how it is implemented in GCC:\nreference back() { _glibcxx_requires_nonempty(); return *(end() - 1); } // definition of end() iterator end() { return iterator(this-\u0026gt;_M_impl._M_finish); } Note that end() points to one past the last element in the vector. That\u0026rsquo;s why we do end()-1 in the definition of back function. This should now be pretty obvious, that why use assertion _glibcxx_requires_nonempty() as we want to make sure that we are returning valid memory location.\n  front(): It should be very similar to what we saw with back(). This returns reference to the first element of the vector.\nreference front() { _glibcxx_requires_nonempty(); return *begin(); } // definition of begin() iterator begin() { return iterator(this-\u0026gt;_M_impl._M_start); } Note how we use the pointers _M_start and _M_finish to access first and the last elements of the vector container respectively.\n  reserve(): Some times we want to pre-allocate memory to a vector container. You can do that using X.reserve(10) to reserve enough size for 10 elements (integers if X is std::vector\u0026lt;int\u0026gt; type).\nvoid reserve(size_type __n) { if (__n \u0026gt; max_size()) _throw_length_error(__N(\u0026#34;vector::reserve\u0026#34;)); if (capacity() \u0026lt; __n) _M_reallocate(__n); } So when you want to pre-allocate memory, there are 3 possibilities:\n There is already enough memory allocated. No need to allocate. (Case of capacity() \u0026gt; __n) There is not enough memory allocated. Need to reallocate memory. (Case of capacity() \u0026lt; __n) The required size is greater than maximum size possible, then lenght error is thrown. (Case of __n \u0026gt; max_size())    size(): This will return the size of the vector container:\nsize_type size() const { return size_type(end() - begin()); } So, let\u0026rsquo;s say you have reserved memory for 10 elements, then size() will return 10.\n  capacity(): This returns the size the container can store currently.\nsize_type capacity() const { return size_type(const_iterator(this-\u0026gt;_M_impl._M_end_addr(), 0) - begin()); } Here, _M_end_addr() returns address of (end of storage + 1) location (if the pointer to this-\u0026gt;_M_impl._M_end_of_storage exists).\n  There maybe a few member functions that I missed, but I\u0026rsquo;m sure the tutorials so far in the Vectors series are (hopefully) enough to help you out with understanding the source code.\nWith this blog post, we are also done with the vector series in C++, and coming up next, we will take a look on using all of this knowledge to implement useful utilities for vectors while implementing libraries and projects, and also other design patterns in C++.\nAcknowledgement I have received a lot of love and support for these blogs, and I am grateful to each and everyone of you! I write these blogs to share what I know with others and in a hope to motivate people to not fear when looking at the source code of any library. I think, reading codes is a good practice.\nI am thankful to Martin York(aka Loki Astari on stackoverflow)) for his constructive feedback on my blogs. Special thanks to Ujval Kapasifor taking time to read through my blogs and giving valuable feedback.\nI was, am and will always be grateful to my elder brother Vishwesh Ravi Shrimali(also my all time mentor) who helped me getting started with C++, AI and whatever I have been doing recently. He inspires me.\n","permalink":"https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-3-diving-deep-into-member-functions-of-vectors/","tags":null,"title":"Understanding how Vectors work in C++ (Part-3): Diving deep into member functions of vectors"},{"categories":null,"contents":"This blog is focused to explain how vectors work in the backend, and we\u0026rsquo;ll specially look at push_back method of the vector container. Looking at the source code helps to understand the implementation, and how vectors can be used efficiently.\nVector Containers are type of sequenced containers in C++ commonly uses as a better alternative of arrays. They are also known as dynamic arrays, and as the term suggests - it\u0026rsquo;s one of the advantages they hold over native arrays in C++. You might have heard of Standard Library containers like vector, set, queue, priority_queue before. They all implement methods defined by the Container Concept.\nA few important notes before we start:\n I\u0026rsquo;m using GCC 10.0.1 which is in the development stage. I\u0026rsquo;ve built GCC 10.0.1 from source on my local system. But everything I discuss here, should be same with GCC 8.4 or GCC 9.3 releases. I assume you are at least using C++11. If for any reason you are using C++98, there might be a few differences (for example, variadic arguments were not present in C++98). To not include lots of macros to check C++ versions, I\u0026rsquo;ve at times assumed the reader is using C++11 or greater. This blog uses lots of C++ Design Patterns that many would not be aware of. I understand it might just be a good idea to explain them first in a blog, but for now - I assume you have at least heard of them and know a thing or two about C++. I\u0026rsquo;ll cover these in future.  Let\u0026rsquo;s start with a basic comparison of using arrays and vectors in C++:\n// Create an array of fixed size: 10 int* InputArray = new int[10]; for (int i = 0; i \u0026lt; 10; i++) { // Let\u0026#39;s assign values to the array  // Values are same as indices  InputArray[i] = i; } We can do the same (from what you see above) using vector:\n// Include this to be able to use vector container #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; InputVector {}; for (int i = 0; i \u0026lt; 10; i++) { InputVector.push_back(i); } While both do the same, but there are many important differences that happen in the backend. Let\u0026rsquo;s start with performance.\n The piece of code using vector containers in C++ took 23.834 microseconds. The piece of code using arrays in C++ took 3.26 microseconds.  If we had to do this for 10k numbers, the performance might be significant:\n The piece of code using vector containers in C++ (for 10k numbers) took 713 microseconds. The piece of code using arrays in C++ took 173 microseconds.  As in software development, there is always a tradeoff. Since vectors aim to provide dynamic memory allocation, they lose some performance while trying to push_back elements in the vectors since the memory is not allocated before. This can be constant if memory is allocated before.\nLet\u0026rsquo;s try to infer this from the source code of vector container. The signature of a vector container looks like this:\ntemplate\u0026lt;typename _Tp, typename _Alloc = std::allocator\u0026lt;_Tp\u0026gt; \u0026gt; class vector : protected _Vector_base\u0026lt;_Tp, _Alloc\u0026gt; Where _Tp is the type of element, and _Alloc is the allocator type (defaults to std::allocator\u0026lt;_Tp\u0026gt;). Let\u0026rsquo;s start from the constructor of vector (when no parameter is passed):\n#if __cplusplus \u0026gt;= 201103L  vector() = default; #else  vector() { } #endif The constructor when called with no params, creates a vector with no elements. As always, there are various ways to initialize a vector object.\nI want to focus more on push_back today, so let\u0026rsquo;s take a look at it\u0026rsquo;s signature. It\u0026rsquo;s located in stl_vector.h file.\n// Note that value_type is defined as: typedef _Tp value_type as a public type void push_back(const value_type\u0026amp; __x) { if (this-\u0026gt;_M_impl._M_finish != this-\u0026gt;_M_impl._M_end_of_storage) { _GLIBCXX_ASAN_ANNOTATE_GROW(1); _Alloc_traits::construct(this-\u0026gt;_M_impl, this-\u0026gt;_M_impl._M_finish, __x); ++this-\u0026gt;_M_impl._M_finish; _GLIBCXX_ASAN_ANNOTATE_GREW(1); } else _M_realloc_insert(end(), __x); } A few notes to take:\n  value_type: This is the type of the elements in the vector container. That is, if the vector is std::vector\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt;, then value_type of the given vector will be std::vector\u0026lt;int\u0026gt;. This comes handy later for type checking and more.\n  _GLIBCXX_ASAN_ANNOTATE_GROW(1): The definition of this macro is:\n#define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \\ typename _Base::_Vector_impl::template _Asan\u0026lt;\u0026gt;::_Grow \\ __attribute__((__unused__)) __grow_guard(this-\u0026gt;_M_impl, (n))  The base struct _Vector_base defines these functions and structs. Let\u0026rsquo;s take a look at struct _Asan. Essentially, all we want to do with the above macro is to grow the vector container memory by n. Since when we insert an element, we only need to grow by 1, so we pass 1 to the macro call.  template\u0026lt;typename = _Tp_alloc_type\u0026gt; struct _Asan { typedef typename __gnu_cxx::__alloc_traits\u0026lt;_Tp_alloc_type\u0026gt;::size_type size_type; struct _Grow { _Grow(_Vector_impl\u0026amp;, size_type) { } void _M_grew(size_type) { } }; // ...  }; If usage of Macros is new to you, please leave it for now as we\u0026rsquo;ll discuss more about these design patterns in future.\n  A note on usage of _M_impl. It is declared as: _Vector_impl\u0026amp; _M_impl in the header file. _Vector_impl is a struct defined as:\nstruct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data { _Vector_impl() _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible\u0026lt;_Tp_alloc_type\u0026gt;::value) : _Tp_alloc_type() { } } // more overloads for the constructor The base struct _Vector_impl_data gives you helpful pointers to access later on:\nstruct _Vector_impl_data { pointer _M_start; pointer _M_finish; pointer _M_end_of_storage; // overloads of constructors } To go deep into the details is not useful here, but as you would have sensed, this helps us to access pointer to the start, finish and end of storage of the vector.\n  You would have guessed by now, that push_back call will add the element to the end (observe _Alloc_traits::construct(this-\u0026gt;_M_impl, this-\u0026gt;_M_impl._M_finish, __x);) and will then increment the variable _M_finish by 1.\nNote how push_back first checks if there is memory available. Of course we have limited memory available with us, and it checks if the end location of the current vector container equals the end storage capacity:\nif (this-\u0026gt;_M_impl._M_finish != this-\u0026gt;_M_impl._M_end_of_storage) { // ... } else { _M_realloc_insert(end(), __x); } So if we have reached the end of storage, it calls _M_realloc_insert(end(), __x). Now what is this? Let\u0026rsquo;s take a look at it\u0026rsquo;s definition:\ntemplate \u0026lt;typename _Tp, typename _Alloc\u0026gt; template\u0026lt;typename... _Args\u0026gt; void vector\u0026lt;_Tp, _Alloc\u0026gt;::_M_realloc_insert(iterator __position, _Args\u0026amp;\u0026amp;... __args) { // ...  pointer __old_start = this-\u0026gt;_M_impl._M_start; pointer __old_finish = this-\u0026gt;_M_impl._M_finish; // Here we have passed __position as end()  // So __elems_before will be total number of elements in our original vector  const size_type __elems_before = __position - begin(); // Declare new starting and finishing pointers  pointer __new_start(this-\u0026gt;_M_allocate(__len)); pointer __new_finish(__new_start); __try { // Allocate memory and copy original vector to the new memory locations  } __catch(...) // Destroy the original memory location  std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator()); // Change starting, finishing and end of storage pointers to new pointers  this-\u0026gt;_M_impl._M_start = __new_start; this-\u0026gt;_M_impl._M_finish = __new_finish; // here __len is 1  this-\u0026gt;_M_impl._M_end_of_storage = __new_start + __len; } Even though the above piece of code might scare a few (it did scare me when I looked at it for the first time), but just saying - this is just 10% of the definition of _M_realloc_insert.\nIf you haven\u0026rsquo;t noticed so far, there is something very puzzling in the code: template\u0026lt;typename... _Args\u0026gt; \u0026ndash; these are variadic arguments introduced in C++11. We\u0026rsquo;ll talk about them later in the series of blogs.\nIntuitively, by calling _M_realloc_insert(end(), __x) all we are trying to do is reallocate memory (end_of_storage + 1), copy the original vector data to the new memory locations, add __x and deallocate (or destroy) the original memory in the heap. This also allows to keep vector to have contiguous memory allocation.\nFor today, I think we discussed a lot about vectors and their implementation in GCC. We\u0026rsquo;ll continue to cover rest of the details in the next part of the blog. I\u0026rsquo;m sure, the next time you plan to use push_back - you\u0026rsquo;ll know how things are happening in the backend. Till then, have fun and take care! :)\nA request For the past year, I\u0026rsquo;ve been writing blogs on PyTorch C++ API. I\u0026rsquo;ve been overwhelmed with your feedback, help and comments. Thank you! This series of blogs on C++, is experimental for now. I love reading source codes, and explaining it to readers. I hope this helps. Please leave your comment and feedback here, or reach out to me at kushashwaravishrimali@gmail.com if you wish. Even if you don\u0026rsquo;t like this, say it! I promise, I\u0026rsquo;ll be better next time.\n","permalink":"https://krshrimali.github.io/posts/2020/04/understanding-how-vectors-work-in-c-part-1-how-does-push_back-work/","tags":null,"title":"Understanding how Vectors work in C++ (Part-1): How does push_back work?"},{"categories":null,"contents":"","permalink":"https://krshrimali.github.io/categories/","tags":null,"title":"Categories"}]